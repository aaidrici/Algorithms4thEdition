package Chapter_2_2;

public class Chapter_2_2 {



    // 2.2.1 see see src\Chapter_2_2\writtenExercises
    // 2.2.2 see see src\Chapter_2_2\writtenExercises
    // 2.2.3 see see src\Chapter_2_2\writtenExercises
    // 2.2.4 indeed the two sub-arrays must be sorted in order. Consider the two sub arrays
    // -> merge([1 3 5 4] & [2 4 6 8]), this will result in [1 2 3 4 5 4 8] which is not sorted.
    // 2.2.5
    // 2.2.6 see TDmerge
    // 2.2.7
    // 2.2.8 If we exclude inequality signs in the comparison count and only consider the call to less()
    //       then the number of comparison is not just linear, it is zero.
    //       If we include inequalities in the comparison count, then sort() - which calls exactly one
    //       inequality operator every time it is called - is called exactly N times. Thus the number
    //       of comparison is indeed linear when the function is already sorted.
    // 2.2.9 see TDmergeWithNonStaticAux
    // 2.2.10 see FasterMerge
    // 2.2.11
    // 2.2.12       ... kinda hard..
    // 2.2.13
    // 2.2.14 see QueueMerging
    // 2.2.15 see BottomUpQueueMergeSort
    // 2.2.16 see NaturalMergeSort (... not sure what needs to be analyzed)
    // 2.2.17 see LinkedListSort
    // 2.2.18 see LinkedListShuffling
    // 2.2.19
    // 2.2.20 see TDmergeSortWithPerm
    // 2.2.21 see Triplicate
    // 2.2.22 see MultiwayMergeSort
    // 2.2.23
    // 2.2.24
    // 2.2.25 see MultiwayMergeSort
    // 2.2.26
    // 2.2.27
    // 2.2.28
    // 2.2.29


}
