package Chapter_3_2;

public class Chapter_3_2 {

    // ** means started but incomplete

    // 3.2.1 refer to Q_3_2_1-2-3-4.jpg
    // 3.2.2 refer to Q_3_2_1-2-3-4.jpg
    // 3.2.3 refer to Q_3_2_1-2-3-4.jpg
    // 3.2.4 refer to Q_3_2_1-2-3-4.jpg
    // 3.2.5 On average, key accessing and key insertion in BST (almost) take the same amount of compare
    // 3 2   Both operators do not have conflicting objectives related to the structure of the tree.
    // 3 2   Optimall
    // 3 2   y, the keys should be inserted such that the BST is balanced. Random key insertion
    // 3 2   should lead to a result not too far from a balanced tree.
    // 3.2.6 see BSTwithHeight
    // 3.2.7 see BSTwithHeight
    // 3.2.8 see BSTwithHeight
    // 3.2.9 see Q_3_2_9.jpg
    // 3.2.10 see TestBST
    // 3.2.11 2^(N-1) in both cases
    // 3.2.12
    // 3.2.13 see nonRecursiveGetAndPut
    // 3.2.14 see nonRecursiveGetAndPut
    // 3.2.15
    // 3.2.16 see Q_3_2_16.jpg
    // 3.2.17 see Q_3_2_17.jpg
    // 3.2.18 see Q_3_2_18-19.jpg
    // 3.2.19 see Q_3_2_18-19.jpg
    // 3.2.20 
    // 3.2.21 see BSTwithRandomKey
    // 3.2.22 A node's successor - by definition - is the node with the smallest key on its right subtree.
    //          Consequently, if its successor had a left child, it would no longer be the smallest node on the
    //          right subtree (it's left child would, or it's left-most grandchild would be the successor)
    //          Same logic applies to the predecessor: the node with the maximal key within its left
    //          subtree cannot have a right-children, otherwise its right children would have a greater key.
    // 3.2.23 No it is not commutative - the successor insertion method is not used when the deleted node has only one child
    // 3.2.24
    // 3.2.25
    // 3.2.26
    // 3.2.27
    // 3.2.28 see BST_cachedNode
    // 3.2.29 see BST added method isBinaryTree
    // 3.2.30 see BST added method isOrdered
    // 3.2.31 see BST added method hasNoDuplicates
    // 3.2.32 see BST added method isBST
    // 3.2.33 see selectRankCheck
    // 3.2.34 see BST_threading
    // 3.2.35                                         ** come back later
    // 3.2.36 yes - use a stack to track the path from the root to the current node. The stack size
    //           should never exceed the tree height.
    // 3.2.37 see BST_printLevel
    // 3.2.38 see BST_TreeDrawing
    // 3.2.39
    // 3.2.40 see BST_height
    // 3.2.41
    // 3.2.42
    // 3.2.43
    // 3.2.44
    // 3.2.45
    // 3.2.46
    // 3.2.47



}
