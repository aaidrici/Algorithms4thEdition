package Chapter_4_3;

public class Chapter_4_3 {

    // 4.3.1 Trivial:  If any cut is performed on the graph, the smallest edge crossing the cut - which must be part of
    //       the MST as shown in proposition J - will remain the smallest edge if all edge are subject to the same offset
    //       and positive scaling.
    // 4.3.2
    // 4.3.3 Proposition: a spanning tree is not minimized unless all vertices are at least connected to their edge with the smaller
    //       weight. proof: same as proposition K but with a cut done around any given vertex.
    //       If each of the V vertex is connected to its smallest adjacent edge, there will be V-1 edges connecting those
    //       V vertices - since the smallest of all edges is shared by two vertex. Generating two MST without violating
    //       the above proposition would require a vertex to have 2 minimum adjacent node, meaning the weight are not distinct.
    // 4.3.4 This is false. A counter example can be generated by adding random edges that all have an identical weight exceeding
    //       the max weight of the original graph (which only contained distinct weights). The MST remain unique, even in the presence of repeated edges.
    // 4.3.5
    // 4.3.6
    // 4.3.7 Multiply weights by -1.
    // 4.3.8 For an edge to be part of an mst, it must be the smallest weighted edge of at least one of its two vertex.
    //       Given edge 'E' has the max weight in a cycle, both its CW and CCW neighbors edges must be smaller. Hence,
    //       edge 'E' cannot be the smaller adjacent edge of any of its two vertex.
    // 4.3.9 see EdgeWeightedGraph
    // 4.3.10
    // 4.3.11
    // 4.3.12 I. yes its lightest edge have to belong to the mst because it is the lightest edge of at east two vertices.
    //        II. Yes, if it is the only edge adjacent to a vertex or its absence would disconnect the graph.
    //        III. No. (counter example: the lightest edge of a cycle connects v-w. If both v and w are connected to other
    //             adjacent edges that are lighter, v-w won't be part of mst)
    // 4.3.13 with 1-2 0.1, 2-3 0.9 and 1-3 0.2, the proposed method will yield the wrong mst if 1 is the init vertex.
    // 4.3.14 loop through all remaining mst edges (worst case ~E) and label edges part of group 'a' bs 'v'.
    // 4.3.15 Run DFS() on either vertex of e while populating an edgeTo[] and onStack[] arrays to find the edges part of
    //        of the created cycle. Then suppress the edge with the largest weight.
    // 4.3.16 Similar to 4.3.15, add edge e (with a value DOUBLE.NEGATIVE_INFINITY) then run DFS() starting the any of
    //        e's vertices while populating an edgeTo[] and onStack[] array to find the edges part of the created cycle.
    //        Let w_max be the maximal weight present on that cycle. e should be in the mst provided its weight is
    //        smaller than w_max.
    // 4.3.17 See EdgeWeightedGraph
    // 4.3.18
    // 4.3.19 insert/retrieve cost for PQs is lg(V) and lg(V). Insert/retrieve cost of unsorted array is 1 and V respectively.
    //        There would be at worst E retrieve operation to be done for this method an every retrieve operation would take
    //        on average V/2. Thus the resulting order of growth is ~VE. This implementation is slower than original MST,
    //        although simpler. Its use for small sparse graph is reasonable.
    // 4.3.20 True. The Kruskal method always picks the smallest edges that is not already connected to two vertices on a tree.
    //        Hence, among all the adjacent edges of a vertex, the smaller one is always picked first by the kruskal method.
    //        This means if a vertex is part of a tree, its adjacent edges not part of that tree (if there are any) can only be larger.
    // 4.3.21 see PrimMST

    // 4.3.22 see KruskalMstForest and PrimMstForest
    // 4.3.23 see VyssotskyMst
    // 4.3.24 see ReverseDeleteAlgorithm
    //           Same as the order of growth for sorting : ~n*log(n)
    //        I. Proof the resulting structure is a tree: at the end of the procedure, the graph is connected and
    //           becomes disconnected if any of its V-1 edges are removed
    //        II. Proof the resulting tree is an mst: The shortest adjacent edge of any vertex is never suppressed because
    //            other adjacent edge would be suppressed beforehand in the procedure. Additionally, there remains at least
    //            adjacent edge for each vertex because connectivity is preserved. Hence, edges belonging to the mst are never suppressed.
    // 4.3.25 No code for this one: I. generate a weightless graph II. use BFS() to propagate around the edges and
    //        associated weights to edges in decreasing order. This will generate the worst case on MinPQ operations
    //        as the last added edge is always the lighter one.
    // 4.3.26               ... hard as fuck
    // 4.3.27
    // 4.3.28
    // 4.3.29 see denseGraph
    // 4.3.30
    // 4.3.31 see PrimMST, LazyPrimMST and Kruskal MST
    // 4.3.32 Lazy approach: force edges of part of set S to weights below the min weight of the graph.
    //                       then solve using Kruskal or Prim's method.
    // 4.3.33 see EdgeWeightedGraph check()


    // 4.3.34
    // 4.3.35
    // 4.3.36
    // 4.3.37
    // 4.3.38
    // 4.3.39
    // 4.3.40
    // 4.3.41
    // 4.3.42
    // 4.3.43 see Boruvka
    // 4.3.44
    // 4.3.45
    // 4.3.46

}
